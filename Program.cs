using System;

namespace Ядерный_Ганди_Арифметическое_переполнение
{
    class Program
    {
        static void Main(string[] args)
        {
            //Баг из игры Цивиллизация про миролюбивого Ганди, который при снижении агрессии устраивал ядерный взрыв

            byte aggression = 1; //Масимальное значение для byte 255, минимальное 0 
            byte appeasement = 2;

            aggression = (byte)(aggression - appeasement);//сужающее преобразование данных

            //фактически, этим вычитанием накручивалась агрессия до 254 единиц, 
            //так как с преведением данных вначале вычитания к byte, мы производили нижнее переполнение данных
            //через 0 попадали в максимальное значиние byte

            Console.WriteLine(aggression);

            int a = int.MaxValue; //присваиваем а максимальное значиние, которое содерижит int
            a = a + 1; //и совершаем верхнее переполнение
            //в результате в а помещается минимальное значение int
            Console.WriteLine("Верхнее переполнение int выглядит так: " + a);

            int b = int.MinValue; //присваиваем минимальное значение, которое может содержать int
            b = b - 1; //и совершанием нижнее переполнения
            //в результате в b помещается максимальное значение int
            Console.WriteLine("Нижнее переполнение int выглядит так: " + b);

            //в случае если не хочется включать автоматическую проверку на арифметическое переполнение
            //ниже написан пример кода, где выполняется арифметическое переполнение для конкретного куска кода
            //прописываем ключевое слово checked и заключаем выражение в круглые скобки
            //aggression = checked((byte)(aggression - appeasement));

            //или же помещаем выражение в фигурные скобки:

            checked
            {
                aggression = (byte)(aggression - appeasement);
            }

            //ключевое слово unchecked, которое НЕ делает проверку на арифметическое преполнение
            //имеет смысл только тогда, когда на уровне всего проекта включена проверка на арифметическое переполнение
            //применяется так как и ключевое слово checked

            //Как включить автоматическую проверку на арифметическое переполнение:
            //на проекте щелкаешь правой кнопкой мышки Свойства - Сборка(будет слева сбоку) - Дополнительно (нужно промотать, оно в самом низу)
            //поставить галочку напротив "Проверть арифметическое переполнение"
            //код перестанет компилироваться, если где-то найдется переполнение
            //компиляция будет идти медленнее

            //чтобы красиво обработать арифметическое переполнение нужно ловить исключение блоком try/caych

            try
            {
                aggression = checked((byte)(aggression - appeasement));
                Console.WriteLine(aggression);
            }
            catch (OverflowException)
            {

                Console.WriteLine("Обнаружено арифметическое переполнение!");
            }

            //арифметическое переполнение с double и float. (Работает одинаково для обоих)
            //как такого переполнение не бывает
            //но при некоторых операциях вместо цифр выводит true
            //Например:

            //Деление на 0

            double c = 1.0 / 0.0;
            Console.WriteLine(double.IsInfinity(c)); // в консоли выведет True

            //Деление нулей на самих себя

            double d = 0.0 / 0.0;
            Console.WriteLine(double.IsNaN(d)); // в консоли выведет True

            double e = double.MinValue + double.MaxValue;
            Console.WriteLine(double.IsInfinity(e)); // в консоли выведет True

            //Теперь арифметическое переполнение для decimal
            //в decimal хранятся денежные единицы (точный тип данных)
            //для финансовых операций
            //поэтому ключевое слово unchecked с decimal не работает
            //и в случае переполнения нам ВСЕГДА прилетит OverflowExepcion

            decimal f = decimal.MaxValue;
            decimal g = decimal.MaxValue;
            decimal result = unchecked(f + g);

            Console.WriteLine(result); //для операндов типа decimal арифметическое переполнение всегда вызывает исключение
        }
    }
}
